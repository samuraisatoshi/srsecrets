{
  "domain_name": "crypto",
  "purpose": "Provides cryptographic primitives including Galois Field arithmetic, polynomial generation, secure random number generation, and complete Shamir's Secret Sharing implementation for air-gapped secret management",
  "classes": [
    {
      "class_name": "GF256",
      "purpose": "Implements GF(2^8) finite field arithmetic with constant-time operations to prevent side-channel attacks",
      "methods": [
        {
          "method_name": "add",
          "purpose": "Addition in GF(2^8) using XOR operation",
          "contract": {
            "inputs": ["a: int", "b: int"],
            "outputs": ["int"],
            "preconditions": ["a and b are valid GF(256) elements (0-255)"],
            "postconditions": ["Returns a + b in GF(256)", "Operation is constant-time"]
          },
          "dependencies": []
        },
        {
          "method_name": "multiply",
          "purpose": "Multiplication in GF(2^8) using precomputed lookup table",
          "contract": {
            "inputs": ["a: int", "b: int"],
            "outputs": ["int"],
            "preconditions": ["a and b are valid GF(256) elements"],
            "postconditions": ["Returns a * b in GF(256)", "Operation is constant-time via table lookup"]
          },
          "dependencies": ["_mulTable"]
        },
        {
          "method_name": "divide",
          "purpose": "Division in GF(2^8) using multiplicative inverse",
          "contract": {
            "inputs": ["a: int", "b: int"],
            "outputs": ["int"],
            "preconditions": ["a and b are valid GF(256) elements", "b != 0"],
            "postconditions": ["Returns a / b in GF(256)", "Throws ArgumentError if b == 0"]
          },
          "dependencies": ["multiply", "_invTable"]
        },
        {
          "method_name": "inverse",
          "purpose": "Compute multiplicative inverse in GF(2^8)",
          "contract": {
            "inputs": ["a: int"],
            "outputs": ["int"],
            "preconditions": ["a is valid GF(256) element"],
            "postconditions": ["Returns multiplicative inverse of a", "Returns 0 for input 0"]
          },
          "dependencies": ["_invTable"]
        },
        {
          "method_name": "lagrangeInterpolate",
          "purpose": "Perform Lagrange interpolation to reconstruct secret from shares",
          "contract": {
            "inputs": ["xValues: List<int>", "yValues: List<int>"],
            "outputs": ["int"],
            "preconditions": ["Arrays have same length", "All values are valid GF(256) elements"],
            "postconditions": ["Returns constant term of interpolating polynomial"]
          },
          "dependencies": ["multiply", "divide", "subtract"]
        },
        {
          "method_name": "evaluatePolynomial",
          "purpose": "Evaluate polynomial at given x using Horner's method",
          "contract": {
            "inputs": ["coefficients: List<int>", "x: int"],
            "outputs": ["int"],
            "preconditions": ["All values are valid GF(256) elements"],
            "postconditions": ["Returns polynomial evaluation at x"]
          },
          "dependencies": ["add", "multiply"]
        }
      ],
      "dependencies": ["SecureRandom", "dart:typed_data"]
    },
    {
      "class_name": "PolynomialGenerator",
      "purpose": "Generates random polynomials for Shamir's Secret Sharing with cryptographically secure coefficients",
      "methods": [
        {
          "method_name": "generatePolynomial",
          "purpose": "Generate random polynomial with secret as constant term",
          "contract": {
            "inputs": ["secret: int", "threshold: int", "fieldSize?: int"],
            "outputs": ["List<int>"],
            "preconditions": ["threshold >= 2", "secret is valid GF(256) element", "threshold <= fieldSize"],
            "postconditions": ["Returns polynomial coefficients", "Constant term equals secret", "Highest degree coefficient is non-zero"]
          },
          "dependencies": ["SecureRandom", "GF256"]
        },
        {
          "method_name": "generateEvaluationPoints",
          "purpose": "Generate unique x-values for share creation",
          "contract": {
            "inputs": ["n: int"],
            "outputs": ["List<int>"],
            "preconditions": ["n >= 1", "n <= 255"],
            "postconditions": ["Returns n unique non-zero x values", "Values are sorted"]
          },
          "dependencies": ["SecureRandom"]
        },
        {
          "method_name": "evaluatePolynomial",
          "purpose": "Evaluate polynomial at x using GF(256) arithmetic",
          "contract": {
            "inputs": ["coefficients: List<int>", "x: int"],
            "outputs": ["int"],
            "preconditions": ["x is valid GF(256) element"],
            "postconditions": ["Returns polynomial value at x"]
          },
          "dependencies": ["GF256.evaluatePolynomial"]
        }
      ],
      "dependencies": ["GF256", "SecureRandom", "dart:typed_data"]
    },
    {
      "class_name": "SecureRandom",
      "purpose": "Cryptographically secure random number generator for field elements",
      "methods": [
        {
          "method_name": "nextGF256Element",
          "purpose": "Generate random element in GF(256)",
          "contract": {
            "inputs": [],
            "outputs": ["int"],
            "preconditions": [],
            "postconditions": ["Returns cryptographically secure random byte (0-255)"]
          },
          "dependencies": ["dart:math.Random.secure"]
        },
        {
          "method_name": "nextNonZeroGF256Element",
          "purpose": "Generate random non-zero element in GF(256)",
          "contract": {
            "inputs": [],
            "outputs": ["int"],
            "preconditions": [],
            "postconditions": ["Returns random byte (1-255)", "Never returns 0"]
          },
          "dependencies": ["nextGF256Element"]
        }
      ],
      "dependencies": ["dart:math"]
    },
    {
      "class_name": "Share",
      "purpose": "Represents a single share in Shamir's Secret Sharing scheme with serialization support",
      "methods": [
        {
          "method_name": "toJson",
          "purpose": "Serialize share to JSON format",
          "contract": {
            "inputs": [],
            "outputs": ["Map<String, dynamic>"],
            "preconditions": [],
            "postconditions": ["Returns JSON-serializable map with x, y, and optional metadata"]
          },
          "dependencies": []
        },
        {
          "method_name": "fromJson",
          "purpose": "Deserialize share from JSON format",
          "contract": {
            "inputs": ["json: Map<String, dynamic>"],
            "outputs": ["Share"],
            "preconditions": ["JSON contains x and y keys"],
            "postconditions": ["Returns reconstructed Share object"]
          },
          "dependencies": []
        },
        {
          "method_name": "toBase64",
          "purpose": "Convert share to base64 string for transmission",
          "contract": {
            "inputs": [],
            "outputs": ["String"],
            "preconditions": [],
            "postconditions": ["Returns base64-encoded share data"]
          },
          "dependencies": ["toJson", "dart:convert"]
        },
        {
          "method_name": "isValid",
          "purpose": "Validate share has legal field values",
          "contract": {
            "inputs": [],
            "outputs": ["bool"],
            "preconditions": [],
            "postconditions": ["Returns true if x and y are valid GF(256) elements and x != 0"]
          },
          "dependencies": ["GF256.isValidElement"]
        }
      ],
      "dependencies": ["GF256", "dart:convert", "dart:typed_data"]
    },
    {
      "class_name": "SecureShare",
      "purpose": "Extended share with integrity verification and metadata tracking",
      "methods": [
        {
          "method_name": "calculateHmac",
          "purpose": "Calculate HMAC-SHA256 for share integrity verification",
          "contract": {
            "inputs": ["x: int", "y: int", "threshold: int", "totalShares: int", "version: int", "identifier?: String"],
            "outputs": ["Uint8List"],
            "preconditions": ["All inputs are valid"],
            "postconditions": ["Returns 32-byte HMAC-SHA256 hash"]
          },
          "dependencies": ["crypto.Hmac", "crypto.sha256"]
        },
        {
          "method_name": "hasValidHmac",
          "purpose": "Verify HMAC integrity using constant-time comparison",
          "contract": {
            "inputs": [],
            "outputs": ["bool"],
            "preconditions": [],
            "postconditions": ["Returns true if HMAC verification passes"]
          },
          "dependencies": ["calculateHmac", "constantTimeEquals"]
        },
        {
          "method_name": "constantTimeEquals",
          "purpose": "Constant-time byte array comparison to prevent timing attacks",
          "contract": {
            "inputs": ["a: Uint8List", "b: Uint8List"],
            "outputs": ["bool"],
            "preconditions": [],
            "postconditions": ["Returns equality result without timing leakage"]
          },
          "dependencies": []
        }
      ],
      "dependencies": ["Share", "crypto.Hmac", "crypto.sha256", "dart:typed_data"]
    },
    {
      "class_name": "ShareSet",
      "purpose": "Container for multiple shares representing multi-byte secrets",
      "methods": [
        {
          "method_name": "getShareAt",
          "purpose": "Retrieve share at specific byte position",
          "contract": {
            "inputs": ["index: int"],
            "outputs": ["Share?"],
            "preconditions": [],
            "postconditions": ["Returns share at index or null if out of bounds"]
          },
          "dependencies": []
        },
        {
          "method_name": "toJson",
          "purpose": "Serialize entire share set to JSON",
          "contract": {
            "inputs": [],
            "outputs": ["Map<String, dynamic>"],
            "preconditions": [],
            "postconditions": ["Returns JSON with shares array and metadata"]
          },
          "dependencies": ["Share.toJson", "ShareSetMetadata.toJson"]
        }
      ],
      "dependencies": ["Share", "ShareSetMetadata", "dart:convert"]
    },
    {
      "class_name": "ShareGenerator",
      "purpose": "Factory for creating shares from secrets using secure random polynomials",
      "methods": [
        {
          "method_name": "generateShares",
          "purpose": "Generate shares for single-byte secret",
          "contract": {
            "inputs": ["secret: int", "threshold: int", "totalShares: int"],
            "outputs": ["List<Share>"],
            "preconditions": ["secret is valid byte", "threshold >= 2", "totalShares >= threshold"],
            "postconditions": ["Returns totalShares number of Share objects"]
          },
          "dependencies": ["PolynomialGenerator", "Share"]
        },
        {
          "method_name": "generateSecureShares",
          "purpose": "Generate shares with integrity checksums and metadata",
          "contract": {
            "inputs": ["secret: int", "threshold: int", "totalShares: int", "identifier?: String", "version?: int"],
            "outputs": ["List<SecureShare>"],
            "preconditions": ["Same as generateShares"],
            "postconditions": ["Returns SecureShare objects with checksums"]
          },
          "dependencies": ["generateShares", "SecureShare"]
        },
        {
          "method_name": "generateShareSets",
          "purpose": "Generate shares for multi-byte secrets",
          "contract": {
            "inputs": ["secretBytes: Uint8List", "threshold: int", "totalShares: int", "description?: String"],
            "outputs": ["List<ShareSet>"],
            "preconditions": ["secretBytes not empty", "threshold and share constraints"],
            "postconditions": ["Returns ShareSet for each participant with shares for all bytes"]
          },
          "dependencies": ["generateShares", "ShareSet", "ShareSetMetadata"]
        }
      ],
      "dependencies": ["PolynomialGenerator", "Share", "SecureShare", "ShareSet", "dart:typed_data"]
    },
    {
      "class_name": "SecretReconstructor",
      "purpose": "Reconstructs secrets from threshold number of shares using Lagrange interpolation",
      "methods": [
        {
          "method_name": "reconstructSecret",
          "purpose": "Reconstruct single-byte secret from shares",
          "contract": {
            "inputs": ["shares: List<Share>"],
            "outputs": ["int"],
            "preconditions": ["shares.length >= threshold", "shares have unique x values"],
            "postconditions": ["Returns original secret byte"]
          },
          "dependencies": ["GF256.lagrangeInterpolate"]
        },
        {
          "method_name": "reconstructFromShareSets",
          "purpose": "Reconstruct multi-byte secret from share sets",
          "contract": {
            "inputs": ["shareSets: List<ShareSet>"],
            "outputs": ["Uint8List"],
            "preconditions": ["shareSets.length >= threshold", "all sets have same metadata"],
            "postconditions": ["Returns original secret bytes"]
          },
          "dependencies": ["reconstructSecret", "ShareSet"]
        },
        {
          "method_name": "canReconstruct",
          "purpose": "Check if shares are sufficient for reconstruction without actually reconstructing",
          "contract": {
            "inputs": ["shares: List<Share>", "threshold: int"],
            "outputs": ["bool"],
            "preconditions": [],
            "postconditions": ["Returns true if reconstruction is possible"]
          },
          "dependencies": []
        },
        {
          "method_name": "reconstructWithVerification",
          "purpose": "Reconstruct with consistency verification using redundant shares",
          "contract": {
            "inputs": ["shares: List<Share>", "threshold: int"],
            "outputs": ["ReconstructionResult"],
            "preconditions": ["shares.length >= threshold"],
            "postconditions": ["Returns result with success status and error detection"]
          },
          "dependencies": ["reconstructSecret", "ReconstructionResult"]
        },
        {
          "method_name": "reconstructFromSecureShares",
          "purpose": "Reconstruct from SecureShare objects with HMAC verification",
          "contract": {
            "inputs": ["shares: List<SecureShare>"],
            "outputs": ["int"],
            "preconditions": ["All shares have valid HMAC", "Consistent metadata"],
            "postconditions": ["Returns original secret or throws on verification failure"]
          },
          "dependencies": ["SecureShare", "reconstructSecret"]
        },
        {
          "method_name": "createProgressive",
          "purpose": "Create progressive reconstructor for incremental share addition",
          "contract": {
            "inputs": ["threshold: int"],
            "outputs": ["ProgressiveReconstructor"],
            "preconditions": ["threshold >= 2"],
            "postconditions": ["Returns initialized progressive reconstructor"]
          },
          "dependencies": ["ProgressiveReconstructor"]
        }
      ],
      "dependencies": ["GF256", "Share", "SecureShare", "ShareSet", "ProgressiveReconstructor", "ReconstructionResult", "dart:typed_data"]
    },
    {
      "class_name": "ShamirSecretSharing",
      "purpose": "Main facade providing high-level API for secret sharing operations",
      "methods": [
        {
          "method_name": "splitByte",
          "purpose": "Split single byte into shares with result metadata",
          "contract": {
            "inputs": ["secret: int", "threshold: int", "shares: int"],
            "outputs": ["SplitResult"],
            "preconditions": ["secret 0-255", "threshold >= 2", "shares <= 255"],
            "postconditions": ["Returns SplitResult with shares and metadata"]
          },
          "dependencies": ["ShareGenerator", "SplitResult"]
        },
        {
          "method_name": "splitBytes",
          "purpose": "Split byte array into share sets",
          "contract": {
            "inputs": ["secret: Uint8List", "threshold: int", "shares: int"],
            "outputs": ["MultiSplitResult"],
            "preconditions": ["secret not empty", "threshold and share constraints"],
            "postconditions": ["Returns MultiSplitResult with share sets"]
          },
          "dependencies": ["ShareGenerator", "MultiSplitResult"]
        },
        {
          "method_name": "splitString",
          "purpose": "Split UTF-8 string into share sets",
          "contract": {
            "inputs": ["secret: String", "threshold: int", "shares: int"],
            "outputs": ["MultiSplitResult"],
            "preconditions": ["secret not empty"],
            "postconditions": ["Returns MultiSplitResult with UTF-8 metadata"]
          },
          "dependencies": ["splitBytes", "dart:convert"]
        },
        {
          "method_name": "combineByte",
          "purpose": "Reconstruct single byte from shares",
          "contract": {
            "inputs": ["shares: List<Share>", "threshold: int"],
            "outputs": ["int"],
            "preconditions": ["shares.length >= threshold"],
            "postconditions": ["Returns original secret byte"]
          },
          "dependencies": ["SecretReconstructor"]
        },
        {
          "method_name": "combineBytes",
          "purpose": "Reconstruct byte array from share sets",
          "contract": {
            "inputs": ["shareSets: List<ShareSet>"],
            "outputs": ["Uint8List"],
            "preconditions": ["shareSets not empty", "sufficient shares"],
            "postconditions": ["Returns original secret bytes"]
          },
          "dependencies": ["SecretReconstructor"]
        },
        {
          "method_name": "combineString",
          "purpose": "Reconstruct UTF-8 string from share sets",
          "contract": {
            "inputs": ["shareSets: List<ShareSet>"],
            "outputs": ["String"],
            "preconditions": ["Same as combineBytes"],
            "postconditions": ["Returns original UTF-8 string"]
          },
          "dependencies": ["combineBytes", "dart:convert"]
        }
      ],
      "dependencies": ["ShareGenerator", "SecretReconstructor", "Share", "ShareSet", "dart:convert", "dart:typed_data"]
    },
    {
      "class_name": "ReconstructionResult",
      "purpose": "Result wrapper for secret reconstruction operations with success status and error handling",
      "methods": [],
      "dependencies": []
    },
    {
      "class_name": "ShareSetMetadata",
      "purpose": "Metadata container for ShareSet objects tracking creation time, description, and share parameters",
      "methods": [
        {
          "method_name": "toJson",
          "purpose": "Serialize metadata to JSON format",
          "contract": {
            "inputs": [],
            "outputs": ["Map<String, dynamic>"],
            "preconditions": [],
            "postconditions": ["Returns JSON-serializable metadata map"]
          },
          "dependencies": []
        },
        {
          "method_name": "fromJson",
          "purpose": "Deserialize metadata from JSON",
          "contract": {
            "inputs": ["json: Map<String, dynamic>"],
            "outputs": ["ShareSetMetadata"],
            "preconditions": ["JSON contains required fields"],
            "postconditions": ["Returns reconstructed metadata object"]
          },
          "dependencies": []
        }
      ],
      "dependencies": []
    },
    {
      "class_name": "SplitResult",
      "purpose": "Result container for single-byte secret splitting operations with shares and metadata",
      "methods": [
        {
          "method_name": "getShare",
          "purpose": "Retrieve share at specific index",
          "contract": {
            "inputs": ["index: int"],
            "outputs": ["SecureShare?"],
            "preconditions": [],
            "postconditions": ["Returns share at index or null if out of bounds"]
          },
          "dependencies": []
        },
        {
          "method_name": "toJson",
          "purpose": "Export shares as JSON array",
          "contract": {
            "inputs": [],
            "outputs": ["List<Map<String, dynamic>>"],
            "preconditions": [],
            "postconditions": ["Returns JSON array of share objects"]
          },
          "dependencies": ["SecureShare.toJson"]
        }
      ],
      "dependencies": ["SecureShare"]
    },
    {
      "class_name": "MultiSplitResult",
      "purpose": "Result container for multi-byte secret splitting with share sets and comprehensive metadata",
      "methods": [
        {
          "method_name": "getShareSet",
          "purpose": "Retrieve share set at specific participant index",
          "contract": {
            "inputs": ["index: int"],
            "outputs": ["ShareSet?"],
            "preconditions": [],
            "postconditions": ["Returns share set or null if out of bounds"]
          },
          "dependencies": []
        },
        {
          "method_name": "toJson",
          "purpose": "Export all share sets as JSON",
          "contract": {
            "inputs": [],
            "outputs": ["Map<String, dynamic>"],
            "preconditions": [],
            "postconditions": ["Returns complete JSON representation"]
          },
          "dependencies": ["ShareSet.toJson"]
        }
      ],
      "dependencies": ["ShareSet"]
    },
    {
      "class_name": "ProgressiveReconstructor",
      "purpose": "Incremental reconstructor that builds secrets as shares are added progressively",
      "methods": [
        {
          "method_name": "addShare",
          "purpose": "Add a share to the reconstruction process",
          "contract": {
            "inputs": ["share: Share"],
            "outputs": ["bool"],
            "preconditions": ["share is valid", "share x-value not already present"],
            "postconditions": ["Returns true if reconstruction completed"]
          },
          "dependencies": ["SecretReconstructor"]
        },
        {
          "method_name": "reset",
          "purpose": "Clear all accumulated shares and reset state",
          "contract": {
            "inputs": [],
            "outputs": [],
            "preconditions": [],
            "postconditions": ["All shares cleared", "isComplete false"]
          },
          "dependencies": []
        }
      ],
      "dependencies": ["Share", "SecretReconstructor"]
    },
    {
      "class_name": "BatchReconstructor",
      "purpose": "Efficient batch processing of multiple secret reconstructions",
      "methods": [
        {
          "method_name": "reconstructMultiple",
          "purpose": "Reconstruct multiple secrets from grouped shares",
          "contract": {
            "inputs": ["shareGroups: List<List<Share>>", "threshold: int"],
            "outputs": ["List<int>"],
            "preconditions": ["Each group has >= threshold shares"],
            "postconditions": ["Returns list of reconstructed secrets"]
          },
          "dependencies": ["SecretReconstructor"]
        },
        {
          "method_name": "reconstructParallel",
          "purpose": "Asynchronous parallel reconstruction for large batches",
          "contract": {
            "inputs": ["shareGroups: List<List<Share>>", "threshold: int"],
            "outputs": ["Future<List<int>>"],
            "preconditions": ["Same as reconstructMultiple"],
            "postconditions": ["Returns Future resolving to reconstructed secrets"]
          },
          "dependencies": ["reconstructMultiple"]
        }
      ],
      "dependencies": ["SecretReconstructor"]
    }
  ]
}